// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: prototypes/web.proto

package prototypes // import "github.com/linkai-io/am/protocservices/prototypes"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type WebCertificate struct {
	OrgID                             int32    `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID                           int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	CertificateID                     int64    `protobuf:"varint,3,opt,name=CertificateID,proto3" json:"CertificateID,omitempty"`
	ResponseTimestamp                 int64    `protobuf:"varint,4,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	HostAddress                       string   `protobuf:"bytes,5,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	Port                              string   `protobuf:"bytes,6,opt,name=Port,proto3" json:"Port,omitempty"`
	Protocol                          string   `protobuf:"bytes,7,opt,name=Protocol,proto3" json:"Protocol,omitempty"`
	KeyExchange                       string   `protobuf:"bytes,8,opt,name=KeyExchange,proto3" json:"KeyExchange,omitempty"`
	KeyExchangeGroup                  string   `protobuf:"bytes,9,opt,name=KeyExchangeGroup,proto3" json:"KeyExchangeGroup,omitempty"`
	Cipher                            string   `protobuf:"bytes,10,opt,name=Cipher,proto3" json:"Cipher,omitempty"`
	Mac                               string   `protobuf:"bytes,11,opt,name=Mac,proto3" json:"Mac,omitempty"`
	CertificateValue                  int32    `protobuf:"varint,12,opt,name=CertificateValue,proto3" json:"CertificateValue,omitempty"`
	SubjectName                       string   `protobuf:"bytes,13,opt,name=SubjectName,proto3" json:"SubjectName,omitempty"`
	SanList                           []string `protobuf:"bytes,14,rep,name=SanList" json:"SanList,omitempty"`
	Issuer                            string   `protobuf:"bytes,15,opt,name=Issuer,proto3" json:"Issuer,omitempty"`
	ValidFrom                         int64    `protobuf:"varint,16,opt,name=ValidFrom,proto3" json:"ValidFrom,omitempty"`
	ValidTo                           int64    `protobuf:"varint,17,opt,name=ValidTo,proto3" json:"ValidTo,omitempty"`
	CertificateTransparencyCompliance string   `protobuf:"bytes,18,opt,name=CertificateTransparencyCompliance,proto3" json:"CertificateTransparencyCompliance,omitempty"`
	IsDeleted                         bool     `protobuf:"varint,19,opt,name=IsDeleted,proto3" json:"IsDeleted,omitempty"`
	XXX_NoUnkeyedLiteral              struct{} `json:"-"`
	XXX_unrecognized                  []byte   `json:"-"`
	XXX_sizecache                     int32    `json:"-"`
}

func (m *WebCertificate) Reset()         { *m = WebCertificate{} }
func (m *WebCertificate) String() string { return proto.CompactTextString(m) }
func (*WebCertificate) ProtoMessage()    {}
func (*WebCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_0a822b7b1e474ec4, []int{0}
}
func (m *WebCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebCertificate.Merge(dst, src)
}
func (m *WebCertificate) XXX_Size() int {
	return m.Size()
}
func (m *WebCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_WebCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_WebCertificate proto.InternalMessageInfo

func (m *WebCertificate) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebCertificate) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebCertificate) GetCertificateID() int64 {
	if m != nil {
		return m.CertificateID
	}
	return 0
}

func (m *WebCertificate) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

func (m *WebCertificate) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *WebCertificate) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *WebCertificate) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *WebCertificate) GetKeyExchange() string {
	if m != nil {
		return m.KeyExchange
	}
	return ""
}

func (m *WebCertificate) GetKeyExchangeGroup() string {
	if m != nil {
		return m.KeyExchangeGroup
	}
	return ""
}

func (m *WebCertificate) GetCipher() string {
	if m != nil {
		return m.Cipher
	}
	return ""
}

func (m *WebCertificate) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *WebCertificate) GetCertificateValue() int32 {
	if m != nil {
		return m.CertificateValue
	}
	return 0
}

func (m *WebCertificate) GetSubjectName() string {
	if m != nil {
		return m.SubjectName
	}
	return ""
}

func (m *WebCertificate) GetSanList() []string {
	if m != nil {
		return m.SanList
	}
	return nil
}

func (m *WebCertificate) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *WebCertificate) GetValidFrom() int64 {
	if m != nil {
		return m.ValidFrom
	}
	return 0
}

func (m *WebCertificate) GetValidTo() int64 {
	if m != nil {
		return m.ValidTo
	}
	return 0
}

func (m *WebCertificate) GetCertificateTransparencyCompliance() string {
	if m != nil {
		return m.CertificateTransparencyCompliance
	}
	return ""
}

func (m *WebCertificate) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

type HTTPResponse struct {
	ResponseID           int64             `protobuf:"varint,1,opt,name=ResponseID,proto3" json:"ResponseID,omitempty"`
	OrgID                int32             `protobuf:"varint,2,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32             `protobuf:"varint,3,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	AddressID            int64             `protobuf:"varint,4,opt,name=AddressID,proto3" json:"AddressID,omitempty"`
	Scheme               string            `protobuf:"bytes,5,opt,name=Scheme,proto3" json:"Scheme,omitempty"`
	HostAddress          string            `protobuf:"bytes,6,opt,name=HostAddress,proto3" json:"HostAddress,omitempty"`
	IPAddress            string            `protobuf:"bytes,7,opt,name=IPAddress,proto3" json:"IPAddress,omitempty"`
	ResponsePort         string            `protobuf:"bytes,8,opt,name=ResponsePort,proto3" json:"ResponsePort,omitempty"`
	RequestedPort        string            `protobuf:"bytes,9,opt,name=RequestedPort,proto3" json:"RequestedPort,omitempty"`
	Status               int32             `protobuf:"varint,10,opt,name=Status,proto3" json:"Status,omitempty"`
	StatusText           string            `protobuf:"bytes,11,opt,name=StatusText,proto3" json:"StatusText,omitempty"`
	URL                  string            `protobuf:"bytes,12,opt,name=URL,proto3" json:"URL,omitempty"`
	Headers              map[string]string `protobuf:"bytes,13,rep,name=Headers" json:"Headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	MimeType             string            `protobuf:"bytes,14,opt,name=MimeType,proto3" json:"MimeType,omitempty"`
	RawBodyLink          string            `protobuf:"bytes,15,opt,name=RawBodyLink,proto3" json:"RawBodyLink,omitempty"`
	RawBodyHash          string            `protobuf:"bytes,16,opt,name=RawBodyHash,proto3" json:"RawBodyHash,omitempty"`
	ResponseTimestamp    int64             `protobuf:"varint,17,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	IsDocument           bool              `protobuf:"varint,18,opt,name=IsDocument,proto3" json:"IsDocument,omitempty"`
	WebCertificate       *WebCertificate   `protobuf:"bytes,19,opt,name=WebCertificate" json:"WebCertificate,omitempty"`
	IsDeleted            bool              `protobuf:"varint,20,opt,name=IsDeleted,proto3" json:"IsDeleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *HTTPResponse) Reset()         { *m = HTTPResponse{} }
func (m *HTTPResponse) String() string { return proto.CompactTextString(m) }
func (*HTTPResponse) ProtoMessage()    {}
func (*HTTPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_0a822b7b1e474ec4, []int{1}
}
func (m *HTTPResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HTTPResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPResponse.Merge(dst, src)
}
func (m *HTTPResponse) XXX_Size() int {
	return m.Size()
}
func (m *HTTPResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPResponse proto.InternalMessageInfo

func (m *HTTPResponse) GetResponseID() int64 {
	if m != nil {
		return m.ResponseID
	}
	return 0
}

func (m *HTTPResponse) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *HTTPResponse) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *HTTPResponse) GetAddressID() int64 {
	if m != nil {
		return m.AddressID
	}
	return 0
}

func (m *HTTPResponse) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *HTTPResponse) GetHostAddress() string {
	if m != nil {
		return m.HostAddress
	}
	return ""
}

func (m *HTTPResponse) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *HTTPResponse) GetResponsePort() string {
	if m != nil {
		return m.ResponsePort
	}
	return ""
}

func (m *HTTPResponse) GetRequestedPort() string {
	if m != nil {
		return m.RequestedPort
	}
	return ""
}

func (m *HTTPResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *HTTPResponse) GetStatusText() string {
	if m != nil {
		return m.StatusText
	}
	return ""
}

func (m *HTTPResponse) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *HTTPResponse) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *HTTPResponse) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *HTTPResponse) GetRawBodyLink() string {
	if m != nil {
		return m.RawBodyLink
	}
	return ""
}

func (m *HTTPResponse) GetRawBodyHash() string {
	if m != nil {
		return m.RawBodyHash
	}
	return ""
}

func (m *HTTPResponse) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

func (m *HTTPResponse) GetIsDocument() bool {
	if m != nil {
		return m.IsDocument
	}
	return false
}

func (m *HTTPResponse) GetWebCertificate() *WebCertificate {
	if m != nil {
		return m.WebCertificate
	}
	return nil
}

func (m *HTTPResponse) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

type WebData struct {
	Address              *AddressData    `protobuf:"bytes,1,opt,name=Address" json:"Address,omitempty"`
	Responses            []*HTTPResponse `protobuf:"bytes,2,rep,name=Responses" json:"Responses,omitempty"`
	SnapshotLink         string          `protobuf:"bytes,3,opt,name=SnapshotLink,proto3" json:"SnapshotLink,omitempty"`
	SerializedDOMHash    string          `protobuf:"bytes,4,opt,name=SerializedDOMHash,proto3" json:"SerializedDOMHash,omitempty"`
	SerializedDOMLink    string          `protobuf:"bytes,5,opt,name=SerializedDOMLink,proto3" json:"SerializedDOMLink,omitempty"`
	ResponseTimestamp    int64           `protobuf:"varint,6,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *WebData) Reset()         { *m = WebData{} }
func (m *WebData) String() string { return proto.CompactTextString(m) }
func (*WebData) ProtoMessage()    {}
func (*WebData) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_0a822b7b1e474ec4, []int{2}
}
func (m *WebData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebData.Merge(dst, src)
}
func (m *WebData) XXX_Size() int {
	return m.Size()
}
func (m *WebData) XXX_DiscardUnknown() {
	xxx_messageInfo_WebData.DiscardUnknown(m)
}

var xxx_messageInfo_WebData proto.InternalMessageInfo

func (m *WebData) GetAddress() *AddressData {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *WebData) GetResponses() []*HTTPResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *WebData) GetSnapshotLink() string {
	if m != nil {
		return m.SnapshotLink
	}
	return ""
}

func (m *WebData) GetSerializedDOMHash() string {
	if m != nil {
		return m.SerializedDOMHash
	}
	return ""
}

func (m *WebData) GetSerializedDOMLink() string {
	if m != nil {
		return m.SerializedDOMLink
	}
	return ""
}

func (m *WebData) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

type WebSnapshot struct {
	OrgID                int32    `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	AddressID            int64    `protobuf:"varint,3,opt,name=AddressID,proto3" json:"AddressID,omitempty"`
	SnapshotID           int64    `protobuf:"varint,4,opt,name=SnapshotID,proto3" json:"SnapshotID,omitempty"`
	SnapshotLink         string   `protobuf:"bytes,5,opt,name=SnapshotLink,proto3" json:"SnapshotLink,omitempty"`
	SerializedDOMLink    string   `protobuf:"bytes,6,opt,name=SerializedDOMLink,proto3" json:"SerializedDOMLink,omitempty"`
	ResponseTimestamp    int64    `protobuf:"varint,7,opt,name=ResponseTimestamp,proto3" json:"ResponseTimestamp,omitempty"`
	IsDeleted            bool     `protobuf:"varint,8,opt,name=IsDeleted,proto3" json:"IsDeleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebSnapshot) Reset()         { *m = WebSnapshot{} }
func (m *WebSnapshot) String() string { return proto.CompactTextString(m) }
func (*WebSnapshot) ProtoMessage()    {}
func (*WebSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_0a822b7b1e474ec4, []int{3}
}
func (m *WebSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSnapshot.Merge(dst, src)
}
func (m *WebSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *WebSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_WebSnapshot proto.InternalMessageInfo

func (m *WebSnapshot) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebSnapshot) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebSnapshot) GetAddressID() int64 {
	if m != nil {
		return m.AddressID
	}
	return 0
}

func (m *WebSnapshot) GetSnapshotID() int64 {
	if m != nil {
		return m.SnapshotID
	}
	return 0
}

func (m *WebSnapshot) GetSnapshotLink() string {
	if m != nil {
		return m.SnapshotLink
	}
	return ""
}

func (m *WebSnapshot) GetSerializedDOMLink() string {
	if m != nil {
		return m.SerializedDOMLink
	}
	return ""
}

func (m *WebSnapshot) GetResponseTimestamp() int64 {
	if m != nil {
		return m.ResponseTimestamp
	}
	return 0
}

func (m *WebSnapshot) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

type WebResponseFilter struct {
	OrgID                int32    `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	WithResponseTime     bool     `protobuf:"varint,3,opt,name=WithResponseTime,proto3" json:"WithResponseTime,omitempty"`
	SinceResponseTime    int64    `protobuf:"varint,4,opt,name=SinceResponseTime,proto3" json:"SinceResponseTime,omitempty"`
	Start                int64    `protobuf:"varint,5,opt,name=Start,proto3" json:"Start,omitempty"`
	Limit                int32    `protobuf:"varint,6,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebResponseFilter) Reset()         { *m = WebResponseFilter{} }
func (m *WebResponseFilter) String() string { return proto.CompactTextString(m) }
func (*WebResponseFilter) ProtoMessage()    {}
func (*WebResponseFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_0a822b7b1e474ec4, []int{4}
}
func (m *WebResponseFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebResponseFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebResponseFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebResponseFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebResponseFilter.Merge(dst, src)
}
func (m *WebResponseFilter) XXX_Size() int {
	return m.Size()
}
func (m *WebResponseFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WebResponseFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WebResponseFilter proto.InternalMessageInfo

func (m *WebResponseFilter) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebResponseFilter) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebResponseFilter) GetWithResponseTime() bool {
	if m != nil {
		return m.WithResponseTime
	}
	return false
}

func (m *WebResponseFilter) GetSinceResponseTime() int64 {
	if m != nil {
		return m.SinceResponseTime
	}
	return 0
}

func (m *WebResponseFilter) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WebResponseFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type WebCertificateFilter struct {
	OrgID                int32    `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	WithResponseTime     bool     `protobuf:"varint,3,opt,name=WithResponseTime,proto3" json:"WithResponseTime,omitempty"`
	SinceResponseTime    int64    `protobuf:"varint,4,opt,name=SinceResponseTime,proto3" json:"SinceResponseTime,omitempty"`
	WithValidTo          bool     `protobuf:"varint,5,opt,name=WithValidTo,proto3" json:"WithValidTo,omitempty"`
	ValidToTime          int64    `protobuf:"varint,6,opt,name=ValidToTime,proto3" json:"ValidToTime,omitempty"`
	Start                int64    `protobuf:"varint,7,opt,name=Start,proto3" json:"Start,omitempty"`
	Limit                int32    `protobuf:"varint,8,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebCertificateFilter) Reset()         { *m = WebCertificateFilter{} }
func (m *WebCertificateFilter) String() string { return proto.CompactTextString(m) }
func (*WebCertificateFilter) ProtoMessage()    {}
func (*WebCertificateFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_0a822b7b1e474ec4, []int{5}
}
func (m *WebCertificateFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebCertificateFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebCertificateFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebCertificateFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebCertificateFilter.Merge(dst, src)
}
func (m *WebCertificateFilter) XXX_Size() int {
	return m.Size()
}
func (m *WebCertificateFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WebCertificateFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WebCertificateFilter proto.InternalMessageInfo

func (m *WebCertificateFilter) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebCertificateFilter) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebCertificateFilter) GetWithResponseTime() bool {
	if m != nil {
		return m.WithResponseTime
	}
	return false
}

func (m *WebCertificateFilter) GetSinceResponseTime() int64 {
	if m != nil {
		return m.SinceResponseTime
	}
	return 0
}

func (m *WebCertificateFilter) GetWithValidTo() bool {
	if m != nil {
		return m.WithValidTo
	}
	return false
}

func (m *WebCertificateFilter) GetValidToTime() int64 {
	if m != nil {
		return m.ValidToTime
	}
	return 0
}

func (m *WebCertificateFilter) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WebCertificateFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type WebSnapshotFilter struct {
	OrgID                int32    `protobuf:"varint,1,opt,name=OrgID,proto3" json:"OrgID,omitempty"`
	GroupID              int32    `protobuf:"varint,2,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	WithResponseTime     bool     `protobuf:"varint,3,opt,name=WithResponseTime,proto3" json:"WithResponseTime,omitempty"`
	SinceResponseTime    int64    `protobuf:"varint,4,opt,name=SinceResponseTime,proto3" json:"SinceResponseTime,omitempty"`
	Start                int64    `protobuf:"varint,5,opt,name=Start,proto3" json:"Start,omitempty"`
	Limit                int32    `protobuf:"varint,6,opt,name=Limit,proto3" json:"Limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WebSnapshotFilter) Reset()         { *m = WebSnapshotFilter{} }
func (m *WebSnapshotFilter) String() string { return proto.CompactTextString(m) }
func (*WebSnapshotFilter) ProtoMessage()    {}
func (*WebSnapshotFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_web_0a822b7b1e474ec4, []int{6}
}
func (m *WebSnapshotFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebSnapshotFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebSnapshotFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WebSnapshotFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebSnapshotFilter.Merge(dst, src)
}
func (m *WebSnapshotFilter) XXX_Size() int {
	return m.Size()
}
func (m *WebSnapshotFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_WebSnapshotFilter.DiscardUnknown(m)
}

var xxx_messageInfo_WebSnapshotFilter proto.InternalMessageInfo

func (m *WebSnapshotFilter) GetOrgID() int32 {
	if m != nil {
		return m.OrgID
	}
	return 0
}

func (m *WebSnapshotFilter) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *WebSnapshotFilter) GetWithResponseTime() bool {
	if m != nil {
		return m.WithResponseTime
	}
	return false
}

func (m *WebSnapshotFilter) GetSinceResponseTime() int64 {
	if m != nil {
		return m.SinceResponseTime
	}
	return 0
}

func (m *WebSnapshotFilter) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WebSnapshotFilter) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func init() {
	proto.RegisterType((*WebCertificate)(nil), "WebCertificate")
	proto.RegisterType((*HTTPResponse)(nil), "HTTPResponse")
	proto.RegisterMapType((map[string]string)(nil), "HTTPResponse.HeadersEntry")
	proto.RegisterType((*WebData)(nil), "WebData")
	proto.RegisterType((*WebSnapshot)(nil), "WebSnapshot")
	proto.RegisterType((*WebResponseFilter)(nil), "WebResponseFilter")
	proto.RegisterType((*WebCertificateFilter)(nil), "WebCertificateFilter")
	proto.RegisterType((*WebSnapshotFilter)(nil), "WebSnapshotFilter")
}
func (m *WebCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebCertificate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.CertificateID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.CertificateID))
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if len(m.HostAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.HostAddress)))
		i += copy(dAtA[i:], m.HostAddress)
	}
	if len(m.Port) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Port)))
		i += copy(dAtA[i:], m.Port)
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if len(m.KeyExchange) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.KeyExchange)))
		i += copy(dAtA[i:], m.KeyExchange)
	}
	if len(m.KeyExchangeGroup) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.KeyExchangeGroup)))
		i += copy(dAtA[i:], m.KeyExchangeGroup)
	}
	if len(m.Cipher) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Cipher)))
		i += copy(dAtA[i:], m.Cipher)
	}
	if len(m.Mac) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Mac)))
		i += copy(dAtA[i:], m.Mac)
	}
	if m.CertificateValue != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.CertificateValue))
	}
	if len(m.SubjectName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SubjectName)))
		i += copy(dAtA[i:], m.SubjectName)
	}
	if len(m.SanList) > 0 {
		for _, s := range m.SanList {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Issuer) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Issuer)))
		i += copy(dAtA[i:], m.Issuer)
	}
	if m.ValidFrom != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ValidFrom))
	}
	if m.ValidTo != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ValidTo))
	}
	if len(m.CertificateTransparencyCompliance) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.CertificateTransparencyCompliance)))
		i += copy(dAtA[i:], m.CertificateTransparencyCompliance)
	}
	if m.IsDeleted {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HTTPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseID))
	}
	if m.OrgID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.AddressID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.AddressID))
	}
	if len(m.Scheme) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.Scheme)))
		i += copy(dAtA[i:], m.Scheme)
	}
	if len(m.HostAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.HostAddress)))
		i += copy(dAtA[i:], m.HostAddress)
	}
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.ResponsePort) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.ResponsePort)))
		i += copy(dAtA[i:], m.ResponsePort)
	}
	if len(m.RequestedPort) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.RequestedPort)))
		i += copy(dAtA[i:], m.RequestedPort)
	}
	if m.Status != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Status))
	}
	if len(m.StatusText) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.StatusText)))
		i += copy(dAtA[i:], m.StatusText)
	}
	if len(m.URL) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	if len(m.Headers) > 0 {
		for k, _ := range m.Headers {
			dAtA[i] = 0x6a
			i++
			v := m.Headers[k]
			mapSize := 1 + len(k) + sovWeb(uint64(len(k))) + 1 + len(v) + sovWeb(uint64(len(v)))
			i = encodeVarintWeb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintWeb(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintWeb(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if len(m.RawBodyLink) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.RawBodyLink)))
		i += copy(dAtA[i:], m.RawBodyLink)
	}
	if len(m.RawBodyHash) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.RawBodyHash)))
		i += copy(dAtA[i:], m.RawBodyHash)
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if m.IsDocument {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.IsDocument {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WebCertificate != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.WebCertificate.Size()))
		n1, err := m.WebCertificate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.IsDeleted {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Address.Size()))
		n2, err := m.Address.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			dAtA[i] = 0x12
			i++
			i = encodeVarintWeb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SnapshotLink) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SnapshotLink)))
		i += copy(dAtA[i:], m.SnapshotLink)
	}
	if len(m.SerializedDOMHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SerializedDOMHash)))
		i += copy(dAtA[i:], m.SerializedDOMHash)
	}
	if len(m.SerializedDOMLink) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SerializedDOMLink)))
		i += copy(dAtA[i:], m.SerializedDOMLink)
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSnapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.AddressID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.AddressID))
	}
	if m.SnapshotID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.SnapshotID))
	}
	if len(m.SnapshotLink) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SnapshotLink)))
		i += copy(dAtA[i:], m.SnapshotLink)
	}
	if len(m.SerializedDOMLink) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWeb(dAtA, i, uint64(len(m.SerializedDOMLink)))
		i += copy(dAtA[i:], m.SerializedDOMLink)
	}
	if m.ResponseTimestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ResponseTimestamp))
	}
	if m.IsDeleted {
		dAtA[i] = 0x40
		i++
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebResponseFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebResponseFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.WithResponseTime {
		dAtA[i] = 0x18
		i++
		if m.WithResponseTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SinceResponseTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.SinceResponseTime))
	}
	if m.Start != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Start))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebCertificateFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebCertificateFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.WithResponseTime {
		dAtA[i] = 0x18
		i++
		if m.WithResponseTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SinceResponseTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.SinceResponseTime))
	}
	if m.WithValidTo {
		dAtA[i] = 0x28
		i++
		if m.WithValidTo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ValidToTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.ValidToTime))
	}
	if m.Start != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Start))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WebSnapshotFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebSnapshotFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OrgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.GroupID))
	}
	if m.WithResponseTime {
		dAtA[i] = 0x18
		i++
		if m.WithResponseTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SinceResponseTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.SinceResponseTime))
	}
	if m.Start != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Start))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintWeb(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintWeb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *WebCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.CertificateID != 0 {
		n += 1 + sovWeb(uint64(m.CertificateID))
	}
	if m.ResponseTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.ResponseTimestamp))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.KeyExchange)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.KeyExchangeGroup)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Cipher)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.CertificateValue != 0 {
		n += 1 + sovWeb(uint64(m.CertificateValue))
	}
	l = len(m.SubjectName)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.SanList) > 0 {
		for _, s := range m.SanList {
			l = len(s)
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ValidFrom != 0 {
		n += 2 + sovWeb(uint64(m.ValidFrom))
	}
	if m.ValidTo != 0 {
		n += 2 + sovWeb(uint64(m.ValidTo))
	}
	l = len(m.CertificateTransparencyCompliance)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.IsDeleted {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HTTPResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseID != 0 {
		n += 1 + sovWeb(uint64(m.ResponseID))
	}
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.AddressID != 0 {
		n += 1 + sovWeb(uint64(m.AddressID))
	}
	l = len(m.Scheme)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.HostAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.ResponsePort)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.RequestedPort)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovWeb(uint64(m.Status))
	}
	l = len(m.StatusText)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovWeb(uint64(len(k))) + 1 + len(v) + sovWeb(uint64(len(v)))
			n += mapEntrySize + 1 + sovWeb(uint64(mapEntrySize))
		}
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.RawBodyLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.RawBodyHash)
	if l > 0 {
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.ResponseTimestamp != 0 {
		n += 2 + sovWeb(uint64(m.ResponseTimestamp))
	}
	if m.IsDocument {
		n += 3
	}
	if m.WebCertificate != nil {
		l = m.WebCertificate.Size()
		n += 2 + l + sovWeb(uint64(l))
	}
	if m.IsDeleted {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovWeb(uint64(l))
	}
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovWeb(uint64(l))
		}
	}
	l = len(m.SnapshotLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.SerializedDOMHash)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.SerializedDOMLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ResponseTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.ResponseTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.AddressID != 0 {
		n += 1 + sovWeb(uint64(m.AddressID))
	}
	if m.SnapshotID != 0 {
		n += 1 + sovWeb(uint64(m.SnapshotID))
	}
	l = len(m.SnapshotLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	l = len(m.SerializedDOMLink)
	if l > 0 {
		n += 1 + l + sovWeb(uint64(l))
	}
	if m.ResponseTimestamp != 0 {
		n += 1 + sovWeb(uint64(m.ResponseTimestamp))
	}
	if m.IsDeleted {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebResponseFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.WithResponseTime {
		n += 2
	}
	if m.SinceResponseTime != 0 {
		n += 1 + sovWeb(uint64(m.SinceResponseTime))
	}
	if m.Start != 0 {
		n += 1 + sovWeb(uint64(m.Start))
	}
	if m.Limit != 0 {
		n += 1 + sovWeb(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebCertificateFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.WithResponseTime {
		n += 2
	}
	if m.SinceResponseTime != 0 {
		n += 1 + sovWeb(uint64(m.SinceResponseTime))
	}
	if m.WithValidTo {
		n += 2
	}
	if m.ValidToTime != 0 {
		n += 1 + sovWeb(uint64(m.ValidToTime))
	}
	if m.Start != 0 {
		n += 1 + sovWeb(uint64(m.Start))
	}
	if m.Limit != 0 {
		n += 1 + sovWeb(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WebSnapshotFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgID != 0 {
		n += 1 + sovWeb(uint64(m.OrgID))
	}
	if m.GroupID != 0 {
		n += 1 + sovWeb(uint64(m.GroupID))
	}
	if m.WithResponseTime {
		n += 2
	}
	if m.SinceResponseTime != 0 {
		n += 1 + sovWeb(uint64(m.SinceResponseTime))
	}
	if m.Start != 0 {
		n += 1 + sovWeb(uint64(m.Start))
	}
	if m.Limit != 0 {
		n += 1 + sovWeb(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovWeb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWeb(x uint64) (n int) {
	return sovWeb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WebCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateID", wireType)
			}
			m.CertificateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertificateID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyExchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyExchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyExchangeGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyExchangeGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cipher", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cipher = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateValue", wireType)
			}
			m.CertificateValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertificateValue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SanList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SanList = append(m.SanList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidFrom", wireType)
			}
			m.ValidFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidFrom |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidTo", wireType)
			}
			m.ValidTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateTransparencyCompliance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateTransparencyCompliance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseID", wireType)
			}
			m.ResponseID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressID", wireType)
			}
			m.AddressID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsePort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponsePort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedPort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWeb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWeb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthWeb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWeb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthWeb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBodyLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBodyLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBodyHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBodyHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDocument", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDocument = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WebCertificate == nil {
				m.WebCertificate = &WebCertificate{}
			}
			if err := m.WebCertificate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &AddressData{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, &HTTPResponse{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedDOMHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedDOMHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedDOMLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedDOMLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressID", wireType)
			}
			m.AddressID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotID", wireType)
			}
			m.SnapshotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedDOMLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWeb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedDOMLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimestamp", wireType)
			}
			m.ResponseTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebResponseFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebResponseFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebResponseFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithResponseTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithResponseTime = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceResponseTime", wireType)
			}
			m.SinceResponseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceResponseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebCertificateFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebCertificateFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebCertificateFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithResponseTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithResponseTime = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceResponseTime", wireType)
			}
			m.SinceResponseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceResponseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithValidTo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithValidTo = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidToTime", wireType)
			}
			m.ValidToTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidToTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebSnapshotFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebSnapshotFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebSnapshotFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgID", wireType)
			}
			m.OrgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithResponseTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithResponseTime = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinceResponseTime", wireType)
			}
			m.SinceResponseTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SinceResponseTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWeb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWeb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWeb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWeb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWeb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWeb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWeb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWeb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWeb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWeb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("prototypes/web.proto", fileDescriptor_web_0a822b7b1e474ec4) }

var fileDescriptor_web_0a822b7b1e474ec4 = []byte{
	// 960 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x4d, 0x6f, 0x23, 0x45,
	0x10, 0x65, 0x3c, 0x19, 0x7f, 0xb4, 0x9d, 0x6c, 0xd2, 0x44, 0xa8, 0x15, 0xad, 0x2c, 0x63, 0x21,
	0x64, 0x2d, 0x60, 0x8b, 0x05, 0x09, 0xb4, 0x37, 0x36, 0xde, 0x25, 0x16, 0x0e, 0x1b, 0xb5, 0xcd,
	0x5a, 0xe2, 0xd6, 0x1e, 0x17, 0x71, 0x13, 0xcf, 0x07, 0xd3, 0xed, 0xdd, 0x35, 0x47, 0xce, 0x1c,
	0x38, 0xc2, 0x3f, 0x82, 0x1b, 0xff, 0x00, 0x14, 0xfe, 0x08, 0xea, 0x9a, 0x99, 0x75, 0x8f, 0x27,
	0x11, 0xe4, 0x06, 0xb7, 0x7e, 0xaf, 0xca, 0xe5, 0xea, 0x57, 0xaf, 0x66, 0x86, 0x1c, 0xc7, 0x49,
	0xa4, 0x23, 0xbd, 0x89, 0x41, 0x0d, 0x5e, 0xc2, 0xbc, 0x8f, 0xf0, 0x84, 0x59, 0xac, 0x58, 0x2c,
	0x12, 0x50, 0x2a, 0x8d, 0x74, 0x7f, 0xf0, 0xc8, 0xc1, 0x0c, 0xe6, 0xa7, 0x90, 0x68, 0xf9, 0x8d,
	0xf4, 0x85, 0x06, 0x7a, 0x4c, 0xbc, 0x67, 0xc9, 0xe5, 0x68, 0xc8, 0x9c, 0x8e, 0xd3, 0xf3, 0x78,
	0x0a, 0x28, 0x23, 0xb5, 0xcf, 0x93, 0x68, 0x1d, 0x8f, 0x86, 0xac, 0x82, 0x7c, 0x0e, 0xe9, 0x3b,
	0x64, 0xdf, 0xfa, 0xf9, 0x68, 0xc8, 0xdc, 0x8e, 0xd3, 0x73, 0x79, 0x91, 0xa4, 0xef, 0x93, 0x23,
	0x0e, 0x2a, 0x8e, 0x42, 0x05, 0x53, 0x19, 0x80, 0xd2, 0x22, 0x88, 0xd9, 0x1e, 0x66, 0x96, 0x03,
	0xb4, 0x43, 0x9a, 0x67, 0x91, 0xd2, 0x9f, 0xa5, 0xbd, 0x32, 0xaf, 0xe3, 0xf4, 0x1a, 0xdc, 0xa6,
	0x28, 0x25, 0x7b, 0x17, 0x51, 0xa2, 0x59, 0x15, 0x43, 0x78, 0xa6, 0x27, 0xa4, 0x7e, 0x61, 0x6e,
	0xe5, 0x47, 0x2b, 0x56, 0x43, 0xfe, 0x35, 0x36, 0x15, 0xbf, 0x80, 0xcd, 0x93, 0x57, 0xfe, 0x52,
	0x84, 0x97, 0xc0, 0xea, 0x69, 0x45, 0x8b, 0xa2, 0x0f, 0xc8, 0xa1, 0x05, 0xf1, 0x76, 0xac, 0x81,
	0x69, 0x25, 0x9e, 0xbe, 0x45, 0xaa, 0xa7, 0x32, 0x5e, 0x42, 0xc2, 0x08, 0x66, 0x64, 0x88, 0x1e,
	0x12, 0xf7, 0x5c, 0xf8, 0xac, 0x89, 0xa4, 0x39, 0x9a, 0xaa, 0x96, 0x10, 0xcf, 0xc5, 0x6a, 0x0d,
	0xac, 0x85, 0x02, 0x96, 0x78, 0xd3, 0xe3, 0x64, 0x3d, 0xff, 0x16, 0x7c, 0xfd, 0xa5, 0x08, 0x80,
	0xed, 0xa7, 0x3d, 0x5a, 0x94, 0x99, 0xc2, 0x44, 0x84, 0x63, 0xa9, 0x34, 0x3b, 0xe8, 0xb8, 0xbd,
	0x06, 0xcf, 0xa1, 0xe9, 0x68, 0xa4, 0xd4, 0x1a, 0x12, 0x76, 0x2f, 0xed, 0x28, 0x45, 0xf4, 0x3e,
	0x69, 0x3c, 0x17, 0x2b, 0xb9, 0x78, 0x9a, 0x44, 0x01, 0x3b, 0x44, 0xbd, 0xb7, 0x84, 0xa9, 0x87,
	0x60, 0x1a, 0xb1, 0x23, 0x8c, 0xe5, 0x90, 0x8e, 0xc9, 0xdb, 0x56, 0x7f, 0xd3, 0x44, 0x84, 0x2a,
	0x16, 0x09, 0x84, 0xfe, 0xe6, 0x34, 0x0a, 0xe2, 0x95, 0x14, 0xa1, 0x0f, 0x8c, 0xe2, 0x5f, 0xfd,
	0x73, 0xa2, 0xe9, 0x62, 0xa4, 0x86, 0xb0, 0x02, 0x0d, 0x0b, 0xf6, 0x66, 0xc7, 0xe9, 0xd5, 0xf9,
	0x96, 0xe8, 0xfe, 0xe1, 0x91, 0xd6, 0xd9, 0x74, 0x7a, 0x91, 0xfb, 0x80, 0xb6, 0x09, 0xc9, 0xcf,
	0x99, 0x0f, 0x5d, 0x6e, 0x31, 0x5b, 0x8b, 0x56, 0x6e, 0xb1, 0xa8, 0x5b, 0xb4, 0xe8, 0x7d, 0xd2,
	0xc8, 0x7c, 0x33, 0x1a, 0x66, 0xa6, 0xdb, 0x12, 0x46, 0xba, 0x89, 0xbf, 0x84, 0x00, 0x32, 0x9f,
	0x65, 0x68, 0xd7, 0x84, 0xd5, 0xb2, 0x09, 0xcd, 0xb5, 0x2e, 0xf2, 0x78, 0xea, 0xb8, 0x2d, 0x41,
	0xbb, 0xa4, 0x95, 0xf7, 0x8c, 0x56, 0x4d, 0x3d, 0x57, 0xe0, 0xcc, 0xf2, 0x70, 0xf8, 0x6e, 0x0d,
	0x4a, 0xc3, 0x02, 0x93, 0x52, 0xc7, 0x15, 0x49, 0xec, 0x50, 0x0b, 0xbd, 0x56, 0x68, 0x37, 0x8f,
	0x67, 0xc8, 0xe8, 0x94, 0x9e, 0xa6, 0xf0, 0x4a, 0x67, 0xae, 0xb3, 0x18, 0x63, 0xc7, 0xaf, 0xf8,
	0x18, 0xfd, 0xd6, 0xe0, 0xe6, 0x48, 0x3f, 0x26, 0xb5, 0x33, 0x10, 0x0b, 0x48, 0x14, 0xdb, 0xef,
	0xb8, 0xbd, 0xe6, 0xc3, 0x93, 0xbe, 0xad, 0x7c, 0x3f, 0x0b, 0x3e, 0x09, 0x75, 0xb2, 0xe1, 0x79,
	0xaa, 0x59, 0xac, 0x73, 0x19, 0xc0, 0x74, 0x13, 0x03, 0x3b, 0x48, 0x17, 0x2b, 0xc7, 0x46, 0x25,
	0x2e, 0x5e, 0x3e, 0x8e, 0x16, 0x9b, 0xb1, 0x0c, 0xaf, 0x32, 0xf7, 0xd9, 0x94, 0x95, 0x71, 0x26,
	0xd4, 0x12, 0x4d, 0xb8, 0xcd, 0x30, 0xd4, 0xcd, 0x0f, 0x87, 0xa3, 0xdb, 0x1e, 0x0e, 0x6d, 0x42,
	0x46, 0x6a, 0x18, 0xf9, 0xeb, 0x00, 0x42, 0x8d, 0x1e, 0xac, 0x73, 0x8b, 0xa1, 0x9f, 0xec, 0x3e,
	0xd2, 0xd0, 0x71, 0xcd, 0x87, 0xf7, 0xfa, 0x45, 0x9a, 0xef, 0x3e, 0xf9, 0x0a, 0x2e, 0x3d, 0xde,
	0x71, 0xe9, 0xc9, 0x23, 0xd2, 0xb2, 0xd5, 0x31, 0xe2, 0x5e, 0xc1, 0x06, 0xdd, 0xd9, 0xe0, 0xe6,
	0x68, 0x6c, 0xf9, 0x02, 0x17, 0xbc, 0x82, 0x5c, 0x0a, 0x1e, 0x55, 0x3e, 0x75, 0xba, 0x3f, 0x56,
	0x48, 0x6d, 0x06, 0xf3, 0xa1, 0xd0, 0x82, 0xbe, 0x4b, 0x6a, 0xb9, 0x65, 0x1c, 0xec, 0xab, 0xd5,
	0xcf, 0xb0, 0x09, 0xf3, 0x3c, 0x48, 0xdf, 0x23, 0x8d, 0xfc, 0xee, 0x8a, 0x55, 0x70, 0x58, 0xfb,
	0x85, 0x61, 0xf1, 0x6d, 0xdc, 0x78, 0x6d, 0x12, 0x8a, 0x58, 0x2d, 0x23, 0x8d, 0x63, 0x70, 0x53,
	0xaf, 0xd9, 0x9c, 0x51, 0x79, 0x02, 0x89, 0x14, 0x2b, 0xf9, 0x3d, 0x2c, 0x86, 0xcf, 0xce, 0x71,
	0x1a, 0x7b, 0x98, 0x58, 0x0e, 0x94, 0xb2, 0xb1, 0xac, 0x77, 0x43, 0x76, 0x5e, 0xbb, 0x3c, 0xc1,
	0xea, 0x2d, 0x13, 0xec, 0xfe, 0x52, 0x21, 0xcd, 0x19, 0xcc, 0xf3, 0xee, 0xee, 0xfc, 0xca, 0x29,
	0xec, 0xb3, 0xbb, 0xbb, 0xcf, 0x66, 0x2b, 0xb2, 0xca, 0xaf, 0xd7, 0xdd, 0x62, 0x4a, 0x5a, 0x79,
	0xff, 0x42, 0x2b, 0x4c, 0xac, 0xde, 0xe9, 0xf6, 0xb5, 0xdb, 0xfc, 0x5b, 0xb0, 0x59, 0x7d, 0xf7,
	0x61, 0xf8, 0x9b, 0x43, 0x8e, 0x66, 0x30, 0xcf, 0x7f, 0xf6, 0x54, 0xae, 0x34, 0x24, 0x77, 0x56,
	0xe8, 0x01, 0x39, 0x9c, 0x49, 0xbd, 0xb4, 0xff, 0x1c, 0x85, 0xaa, 0xf3, 0x12, 0x8f, 0x77, 0x95,
	0xa1, 0x0f, 0x85, 0xe4, 0xec, 0xd5, 0x5c, 0x0a, 0x98, 0x4e, 0x26, 0x5a, 0x24, 0x1a, 0x65, 0x73,
	0x79, 0x0a, 0x0c, 0x3b, 0x96, 0x81, 0x4c, 0xdf, 0xc7, 0x1e, 0x4f, 0x41, 0xf7, 0xa7, 0x0a, 0x39,
	0x2e, 0xee, 0xd8, 0x7f, 0xee, 0x3a, 0x1d, 0xd2, 0x34, 0x15, 0xf2, 0xb7, 0xa0, 0x87, 0x45, 0x6d,
	0xca, 0x64, 0x64, 0x47, 0xac, 0x94, 0x9a, 0xda, 0xa6, 0xb6, 0x92, 0xd4, 0x6e, 0x94, 0xa4, 0x6e,
	0x4b, 0x92, 0x8d, 0x37, 0x37, 0xdb, 0xff, 0x79, 0xbc, 0x8f, 0x4f, 0x7f, 0xbd, 0x6e, 0x3b, 0xbf,
	0x5f, 0xb7, 0x9d, 0x3f, 0xaf, 0xdb, 0xce, 0xcf, 0x7f, 0xb5, 0xdf, 0xf8, 0xfa, 0xc3, 0x4b, 0xa9,
	0x97, 0xeb, 0x79, 0xdf, 0x8f, 0x82, 0xc1, 0x4a, 0x86, 0x57, 0x42, 0x7e, 0x20, 0xa3, 0x81, 0x08,
	0x06, 0xf8, 0xb5, 0xe9, 0x2b, 0x48, 0x5e, 0x48, 0x1f, 0xd4, 0x60, 0xfb, 0x3d, 0x3a, 0xaf, 0xe2,
	0xf9, 0xa3, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x96, 0x2c, 0x84, 0xba, 0x0a, 0x00, 0x00,
}
